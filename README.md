# 项目简介

## 项目地址：
  http://1.117.171.95/zls.html
## 使用技术：
线程池、多线程、HTTP解析，socket编程，IO多路复用。
## 项目描述：
使用Reactor模型，并使用多线程提高并发度。为避免线程频繁创建和销毁带来的开销，使用线程池，在程序的开始创建固定数量的线程。使用epoll作为IO多路复用的实现方式。当前实现功能为客户端输入特定网址后经由服务器解析POST报文即可访问对应网站；后续考虑实现解析GET报文完成网页留言板功能。
![Image text](https://ftp.bmp.ovh/imgs/2021/07/6fb1d72408fd9950.png)

# server1.1

## 更新内容
1.1版主要解决了一个书里关于大文件传输的bug。

## BUG发现
  在云端搭完服务器后，我很开心地发到好友群里让大家访问欣赏，并且还写了个为这个群定制的网页，如下图：
![Image text](https://ftp.bmp.ovh/imgs/2021/07/a2f3aa6eb35f1767.jpg)
  但我发现左边那个帅哥的照片（不是我哦。。）总是刷到一半就刷不出来，其他的图片倒是每次都能刷出来，我就觉得有点奇怪，看了下图片大小，这个头像是几百k，其他图片是几十k。连几百K的图片都不能成功显示吗？我表示这可不行！为了验证是不是因为文件过大导致刷不出来，我测试了一张6M的照片，如图所示：
 ![Image text](https://ftp.bmp.ovh/imgs/2021/07/9833614b976420cd.jpg)
 图片确实显示不全，而且我还发现其实图片的最右侧是能显示出一条纵向的小条条，给人的感觉就是图片刚开始传（而且是从右向左传的），就结束了。这肯定有问题！
 
 ## BUG解决
 经过对源码的阅读，我发现http_conn.cpp Line325:
 int bytes_to_send = m_write_idx;// 将要发送的字节 （m_write_idx）写缓冲区中待发送的字节数 要发送的数据字节只包含了响应行，不包括响应体（要传的文件），所以文件可能就传了一点点就结束了！于是这一行修改为：bytes_to_send = m_write_idx + m_file_stat.st_size; 同时process_write()和write()也做了相应的修改，代码中已注释并说明，搜索v1.1即可！修改完之后运行的效果说明bug已修复：
 ![Image text]( https://ftp.bmp.ovh/imgs/2021/07/4bdc40c8c29daa1d.png)
 
 

# server1.0

1.0版本主要工作是看着书敲一遍代码，彻彻底底地看懂代码，画出流程框图，添加必要的注释。本地跑通后，上传到腾讯云。同时，考虑了一下几个问题：

1.为什么其他网站不用输入端口号？

HTTP默认端口是80 把程序绑定的端口号设置为80就可以不输入端口号，直接把原先的10001端口号改成80，无效。以为是腾讯云平台的问题，问了客服无解，想着只能用iptables做本地端口转发，查阅资料时偶然发现Linux限制1024一下端口必须有root权限才能开启，所以增加sudo命令，把程序的端口号设置为80，成功！但了解到这样做不是很安全，因为1024前的端口号一般不直接绑定，因此用以下语句做端口转发：
iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 10001
实现需求效果。


2.为什么要捕捉SIGPIPE信号？

对一个对端已经关闭的socket调用两次write，第二次将会生成SIGPIPE信号，该信号默认结束进程。因此，需要捕捉该信号，忽略它（SIG_IGN）。

3.threadpool.h line45:if(pthread_create(m_threads + i, NULL, worker, this) != 0)为什么要求worker一定是静态函数？

worker必须是静态函数C++的类成员函数都有一个默认参数 this 指针，而线程调用的时候，限制了只能有一个参数 void* arg，如果不设置成静态在调用的时候会出现this 和arg都给worker 导致错误。

